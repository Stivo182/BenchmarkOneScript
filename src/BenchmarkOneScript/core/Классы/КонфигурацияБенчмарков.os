#Использовать asserts

Перем _Стратегия; // см. СтратегииЗапускаБенчмарка
Перем _КоличествоИтераций; // Число
Перем _КоличествоВызововЗаИтерацию; // Число
Перем _КоличествоПрогревочныхИтераций; // Число
Перем _МинимальноеВремяИтерации; // Число - мс
Перем _МинимальноеКоличествоВызововЗаИтерацию; // Число
Перем _СортировкаОтчета; // см. СортировкиОтчетаБенчмарков
Перем _ТребуетсяМониторингПамяти; // Булево
Перем _Параметры; // Массив из ПараметрБенчмарка
Перем _Обработчики; // Соответствие

// Конфигурация бенчмарков
//
// Параметры:
//   Источник - Тип, Произвольный - Тип или объект бенчмарков
Процедура ПриСозданииОбъекта(Источник = Неопределено)

	КоличествоИтераций = 15;
	КоличествоВызововЗаИтерацию = 0;
	КоличествоПрогревочныхИтераций = 6;
	МинимальноеВремяИтерации = 100;
	МинимальноеКоличествоВызововЗаИтерацию = 4;
	
	_Параметры = Новый Массив();
	_Обработчики = Новый Соответствие();
	_ТребуетсяМониторингПамяти = Ложь;

	УстановитьСтратегию(СтратегииЗапускаБенчмарка.ПропускнаяСпособность);
	УстановитьКоличествоИтераций(КоличествоИтераций);
	УстановитьКоличествоВызововЗаИтерацию(КоличествоВызововЗаИтерацию);
	УстановитьКоличествоПрогревочныхИтераций(КоличествоПрогревочныхИтераций);
	УстановитьМинимальноеВремяИтерации(МинимальноеВремяИтерации);
	УстановитьМинимальноеКоличествоВызововЗаИтерацию(МинимальноеКоличествоВызововЗаИтерацию);

	Если Не Источник = Неопределено Тогда
		ИзвлекательКонфигурацииБенчмарков.Извлечь(Источник, ЭтотОбъект);
	КонецЕсли;

КонецПроцедуры

#Область ПрограммныйИнтерфейс

// Устанавливает количество итераций для основных этапов (ЭтапыБенчмарка.Результат, ЭтапыБенчмарка.Память)
//
// Используется для тонкой настройки баланса между точностью измерений и временем выполнения теста.
// Увеличение итераций повышает стабильность результатов, но увеличивает общее время прогона.
//
// Параметры:
//   КоличествоИтераций - Число
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьКоличествоИтераций(КоличествоИтераций) Экспорт

	Ожидаем.Что(КоличествоИтераций, "Количество итераций не может быть меньше 1").Больше(0);

	_КоличествоИтераций = КоличествоИтераций;

	Возврат ЭтотОбъект;

КонецФункции

// Количество итераций для основных этапов (ЭтапыБенчмарка.Результат, ЭтапыБенчмарка.Память)
//
// Возвращаемое значение:
//   Число
Функция КоличествоИтераций() Экспорт

	Возврат _КоличествоИтераций;
	
КонецФункции

// Устанавливает количество вызовов за итерацию
//
// Используется для увеличения времени выполнения итерации, что повышает точность измерений
// для методов с очень быстрым временем выполнения.
//
// Если установлено "0", то количество будет рассчитано автоматически.
//
// Параметры:
//   КоличествоВызововЗаИтерацию - Число
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьКоличествоВызововЗаИтерацию(КоличествоВызововЗаИтерацию) Экспорт

	Ожидаем.Что(КоличествоВызововЗаИтерацию, "Количество вызовов за итерацию не может быть меньше 0").БольшеИлиРавно(0);

	_КоличествоВызововЗаИтерацию = КоличествоВызововЗаИтерацию;

	Возврат ЭтотОбъект;
	
КонецФункции

// Количество вызовов за итерацию
//
// Возвращаемое значение:
//   Число
Функция КоличествоВызововЗаИтерацию() Экспорт

	Возврат _КоличествоВызововЗаИтерацию;

КонецФункции

// Устанавливает количество прогревочных итераций для подготовки окружения перед выполнением 
// основных замеров бенчмарка.
//
// Прогревочные итерации используются для стабилизации системы: прогрев кэшей, 
// инициализация внешних ресурсов. Результаты этих итераций не учитываются в финальной статистике.
//
// - Если установлено "0", то прогревочный этап будет пропущен. 
// - Игнорируется для стратегии "ХолодныйЗапуск".
//
// Параметры:
//   КоличествоПрогревочныхИтераций - Число
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьКоличествоПрогревочныхИтераций(КоличествоПрогревочныхИтераций) Экспорт

	Ожидаем.Что(КоличествоПрогревочныхИтераций, "Количество прогревочных итераций не может быть меньше 0").БольшеИлиРавно(0);

	_КоличествоПрогревочныхИтераций = КоличествоПрогревочныхИтераций;

	Возврат ЭтотОбъект;
	
КонецФункции

// Количество прогревочных итераций для подготовки окружения перед выполнением основных замеров бенчмарка.
//
// Возвращаемое значение:
//   Число
Функция КоличествоПрогревочныхИтераций() Экспорт

	Возврат _КоличествоПрогревочныхИтераций;

КонецФункции

// Устанавливает минимальное время выполнения одной итерации бенчмарка в миллисекундах
//
// BenchmarkOneScript динамически подбирает количество вызовов за итерацию (см. АннотацияКоличествоВызововЗаИтерацию) так, 
// чтобы одна итерация длилась не меньше указанного времени. 
// Увеличивает стабильность замеров для коротких операций.
//
// Игнорируется для стратегии "ХолодныйЗапуск".
//
// Параметры:
//   МинимальноеВремяИтерации - Число - Миллисекунд
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьМинимальноеВремяИтерации(МинимальноеВремяИтерации) Экспорт

	Ожидаем.Что(МинимальноеВремяИтерации, "Минимальное время итерации не может быть меньше 1 мс").Больше(0);

	_МинимальноеВремяИтерации = МинимальноеВремяИтерации;

	Возврат ЭтотОбъект;

КонецФункции

// Минимальное время выполнения одной итерации бенчмарка в миллисекундах
//
// Возвращаемое значение:
//   Число - Миллисекунд
Функция МинимальноеВремяИтерации() Экспорт

	Возврат _МинимальноеВремяИтерации;

КонецФункции

// Устанавливает минимальное количество вызовов метода в течение одной итерации бенчмарка
//
// Гарантирует, что метод будет выполнен не менее указанного числа раз, 
// даже если автоматический расчет предполагает меньшее количество вызовов.
//
// Игнорируется для стратегии "ХолодныйЗапуск".
//
// Параметры:
//   МинимальноеКоличествоВызововЗаИтерацию - Число
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьМинимальноеКоличествоВызововЗаИтерацию(МинимальноеКоличествоВызововЗаИтерацию) Экспорт

	Ожидаем
		.Что(МинимальноеКоличествоВызововЗаИтерацию, "Минимальное количество вызовов за итерацию не может быть меньше 1")
		.Больше(0);

	_МинимальноеКоличествоВызововЗаИтерацию = МинимальноеКоличествоВызововЗаИтерацию;

	Возврат ЭтотОбъект;

КонецФункции

// Минимальное количество вызовов метода в течение одной итерации бенчмарка
//
// Используется как начальное количество при расчете количества вызовов за итерацию.
// Игнорируется для стратегии "ХолодныйЗапуск".
//
// Возвращаемое значение:
//   Число
Функция МинимальноеКоличествоВызововЗаИтерацию() Экспорт

	Возврат _МинимальноеКоличествоВызововЗаИтерацию;

КонецФункции

// Устанавливает стратегию запуска бенчмарков
//
// Параметры:
//   Стратегия - см. СтратегииЗапускаБенчмарка
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьСтратегию(Стратегия) Экспорт

	_Стратегия = Стратегия;

	Возврат ЭтотОбъект;

КонецФункции

// Стратегия запуска бенчмарков
//
// Возвращаемое значение:
//   см. СтратегииЗапускаБенчмарка
Функция Стратегия() Экспорт

	Возврат _Стратегия;

КонецФункции

// Добавляет параметр в набор, позволяя запускать тесты с разными наборами входных данных
//
// Метод бенчмарка будет выполнен для каждой уникальной комбинации значений параметров.
// Позволяет анализировать производительность в зависимости от входных условий.
//
// Параметры:
//   Имя - Строка - Имя публичного поля класса бенчмарка
//   Значение - Произвольный
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция ДобавитьПараметр(Имя, Значение) Экспорт

	_Параметры.Добавить(Новый ПараметрБенчмарка(Имя, Значение, Ложь));

	Возврат ЭтотОбъект;

КонецФункции

// Параметры, используемые для запуска бенчмарков с разными наборами входных данных
// 
// Возвращаемое значение:
//   Массив из 

Функция Параметры() Экспорт

	Возврат Новый Массив(Новый ФиксированныйМассив(_Параметры));

КонецФункции

// Очищает набор параметров
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция ОчиститьПараметры() Экспорт

	_Параметры.Очистить();

	Возврат ЭтотОбъект;
	
КонецФункции

// Имена параметров (публичных полей класса)
//
// Возвращаемое значение:
//   Массив из Строка
Функция ИменаПараметров() Экспорт

	Имена = Новый Массив();

	Для Каждого Параметр Из _Параметры Цикл
		Имя = Параметр.Имя;
		Если Имена.Найти(Имя) = Неопределено Тогда
			Имена.Добавить(Имя);
		КонецЕсли;
	КонецЦикла;

	Возврат Имена;

КонецФункции

// Устанавливает сортировку результатов в отчете
//
// Параметры:
//   Сортировка - см. СортировкиОтчетаБенчмарков
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьСортировкуОтчета(Сортировка) Экспорт

	_СортировкаОтчета = Сортировка;

	Возврат ЭтотОбъект;

КонецФункции

// Сортировка результатов в отчете
//
// Возвращаемое значение:
//   см. СортировкиОтчетаБенчмарков
Функция СортировкаОтчета() Экспорт

	Возврат _СортировкаОтчета;

КонецФункции

// Добавляет этап мониторинга выделения памяти и сборок мусора (GC)
//
// При использовании этой аннотации в отчете будут отображаться:
// - Аллокации памяти в байтах за итерацию
// - (нет) Количество сборок мусора для поколений (Gen 0, Gen 1, Gen 2) - пока нет необходимости, но средство получения есть
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция ДобавитьМониторингПамяти() Экспорт

	_ТребуетсяМониторингПамяти = Истина;

	Возврат ЭтотОбъект;
	
КонецФункции

// Треубется мониторинг выделения памяти и сборок мусора (GC)
//
// Возвращаемое значение:
//   Булево
Функция ТребуетсяМониторингПамяти() Экспорт

	Возврат _ТребуетсяМониторингПамяти;
	
КонецФункции

// Устанавливает обработчик, вызываемый перед каждым запуском бенчмарка
//
// Параметры:
//   Делегат, Неопределено - Делегат:
//     * Контекст - Структура:
//        ** ДескрипторБенчмарка - ДескрипторБенчмарка
//        ** ПараметрыМетода - Массив из Произвольный
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьОбработчикПередКаждым(Делегат) Экспорт
	
	ДобавитьОбработчикСобытия("ПередКаждым", Делегат);
	
КонецФункции

// Устанавливает обработчик, вызываемый после каждого запуска бенчмарка
//
// Параметры:
//   Делегат, Неопределено - Делегат:
//     * Контекст - Структура:
//        ** ДескрипторБенчмарка - ДескрипторБенчмарка
//        ** Параметры - Массив из ПараметрБенчмарка
//        ** Замеры - Массив из см. ЗапускательБенчмарков.НовыйРезультатИтерации
//        ** Статистика - см. СтатистикаБенчмарков.СтатистикаЗамеров
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьОбработчикПослеКаждого(Делегат) Экспорт

	ДобавитьОбработчикСобытия("ПослеКаждого", Делегат);

	Возврат ЭтотОбъект;
	
КонецФункции

// Устанавливает обработчик, вызываемый перед запуском всех бенчмарков
//
// Используется для подготовки данных, инициализации ресурсов или настройки 
// окружения перед выполнением бенчмарков.
//
// Параметры:
//   Делегат, Неопределено - Делегат:
//     * Контекст - Структура:
//        ** Конфигурация - КонфигурацияБенчмарков
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьОбработчикПередВсеми(Делегат) Экспорт

	ДобавитьОбработчикСобытия("ПередВсеми", Делегат);

	Возврат ЭтотОбъект;

КонецФункции

// Устанавливает обработчик, вызываемый после запуска всех бенчмарков
//
// Используется для освобождения ресурсов, сброса состояний 
// или финализации данных после выполнения всех бенчмарков.
//
// Параметры:
//   Делегат, Неопределено - Делегат:
//     * Контекст - Структура:
//        ** ДескрипторыБенчмарков - КоллекцияДескрипторовБенчмарков
//        ** Конфигурация - КонфигурацияБенчмарков
//        ** РезультатыЗапусков - см. НоваяТаблицаРезультатов
//        ** Отчет - ОтчетБенчмарков
//        ** СредаОкружения - СредаОкруженияБенчмарков
//
// Возвращаемое значение:
//   ЭтотОбъект
Функция УстановитьОбработчикПослеВсех(Делегат) Экспорт

	ДобавитьОбработчикСобытия("ПослеВсех", Делегат);

	Возврат ЭтотОбъект;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Функция ОбработчикСобытия(ИмяСобытия, Контекст = Неопределено) Экспорт

	Описание = _Обработчики[ИмяСобытия];
	Если Описание = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если Описание.ЕстьПараметры Тогда
		Описание.Делегат.УстановитьПараметры(Контекст);
	КонецЕсли;

	Возврат Описание.Делегат;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ДобавитьОбработчикСобытия(ИмяСобытия, Делегат)

	Если Делегат = Неопределено Тогда
		_Обработчики[ИмяСобытия] = Неопределено;
		Возврат;
	КонецЕсли;

	РефлекторОбъекта = Новый РефлекторОбъекта(Делегат.Объект());
	ТаблицаМетодов = РефлекторОбъекта.ПолучитьТаблицуМетодов(, Ложь);
	СвойстваМетода = ТаблицаМетодов.Найти(Делегат.ИмяМетода(), "Имя");

	ЕстьПараметры = СвойстваМетода.Параметры.Количество() > 0;

	_Обработчики.Вставить(ИмяСобытия, Новый Структура("Делегат, ЕстьПараметры", Делегат, ЕстьПараметры));

КонецПроцедуры

#КонецОбласти